清晰的描述程式碼邏輯結構範例

有時學生看不懂演算法或函數的功能或結構，希望LLM可以幫助學生解析程式碼。。

這是我的評分標準 請盡量完成
準確性 正確判斷演算法或函數名稱與功能
詳細性 詳細描述，包括主要邏輯和次要邏輯
正向建議 能夠教導演算法或函數知識(100%)

範例:
{
  "instruction": "請幫我清楚地描述這段程式碼的邏輯結構，並教導其演算法或函數知識。",
  "input": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
  "output": "這段程式碼實現的是 **氣泡排序演算法**（Bubble Sort）。該演算法的主要功能是將輸入的數列按從小到大的順序進行排序。\n\n**主要邏輯**：\n1. `n = len(arr)`：首先，程式碼計算輸入數列 `arr` 的長度，並將其儲存在變數 `n` 中。\n2. `for i in range(n)`：外層迴圈的目的是控制排序的輪數。由於每一輪排序至少會將一個最大（或最小）的元素移動到數列的最右端，所以總共需要進行 `n` 輪排序。\n3. `for j in range(0, n-i-1)`：內層迴圈的目的是進行相鄰元素的比較和交換。隨著每一輪排序的進行，最後幾個元素已經是排序好的，所以每輪需要比較的元素數量會減少。\n4. `if arr[j] > arr[j+1]`：如果當前元素 `arr[j]` 大於下一個元素 `arr[j+1]`，則交換它們的位置，使得較大的元素向數列右端移動。\n5. `arr[j], arr[j+1] = arr[j+1], arr[j]`：執行元素交換。\n6. 最後返回排序後的數列 `arr`。\n\n**次要邏輯**：\n- 在每次外層迴圈的迭代中，內層迴圈會比較越來越少的元素，因為每次迭代後，最大的元素都會移動到數列的最右端。\n- 氣泡排序演算法的時間複雜度為 `O(n^2)`，因為最壞情況下需要進行 `n*(n-1)/2` 次比較和交換。\n\n**正向建議**：\n- **了解氣泡排序的特性**：氣泡排序是一種簡單的排序演算法，適用於小型數列的排序。由於其時間複雜度較高，不適合用於大型數列排序。理解氣泡排序的工作原理有助於學習者掌握排序的基本概念。\n- **學習其他排序演算法**：建議學習者進一步探索其他更高效的排序演算法，如快速排序（Quick Sort）、合併排序（Merge Sort）等，這些演算法在大數據集上表現更好。\n- **改進建議**：對於學習者來說，理解如何利用氣泡排序的基本邏輯，進而優化程式碼或應用更適合的排序演算法，是一個重要的進階步驟。"
}

請你扮演一個Python專業出題者
給我一個滿足上面格式與標準的範例